CaptivePairs = function(n.offs, fecundity, equalcaptive, allonecaptive, capvariation, cappop){
  n.captive.offspring = n.offs
  if(equalcaptive == 1){
    maxpairs    = min(nrow(cappop[cappop[,7]==0,,drop=FALSE]), nrow(cappop[cappop[,7]==1,,drop=FALSE]))
    if(maxpairs>0){
      numberpairs = maxpairs
      while(n.captive.offspring / numberpairs < 1){
        numberpairs = numberpairs - 1
      }
      base        = round((n.captive.offspring / numberpairs), 0)
      if(base<1){base = 1}
      totalpairs  = rep(base, maxpairs)
      # add one offspring to each pair until the total reaches number of offspring needed
      i = 1
      while(sum(totalpairs) < n.captive.offspring){
        totalpairs[i] = totalpairs[i] + 1
        i = i + 1
        if(i>=length(totalpairs)){
          i = 1
        }
      }
      cap.pairs = totalpairs
      return(cap.pairs)
    }else{
      cap.pairs = 0
      return(cap.pairs)
    }

  }
  if(allonecaptive == 1){
    cap.pairs = n.captive.offspring
    return(cap.pairs)
  }
  if(capvariation>0){
    #fecundity == 1 - this assumes that exactly 0 or 1 offspring are produced per pair
    if(fecundity==1){
      pairs = rep(1, n.offs)
      return(pairs)
    }
    
    #fecundity == 2 - this assumes that each birth results in two offspring, as in tamarins, but that 1/2 of the time only one survives
    if(fecundity==2){
      twins   = rep(2, (n.offs/4))
      singles = rep(1, n.offs - sum(twins))
      pairs   = c(singles, twins)
      return(pairs)
    }
    
    # fecundity 3-9
    #if(fecundity>=3 & fecundity<10){
    #  hist(rgamma(n.offs*10, shape = 0.5, rate = 0.5), breaks = 50) # histogram of distribution
    #  mean(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
    #  var(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
    #  g.shape = 0.5 
    #  g.rate = 0.5
    #}  
    
    # fecundity >= 10
    if(fecundity>=10 & fecundity<100){
      #hist(rgamma(n.offs*10, shape = 0.5, rate = 0.25), breaks = 50) # histogram of distribution
      #mean(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
      #var(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
      g.shape = 0.5 
      g.rate = 0.25
    }  
    
    if(fecundity>=100){
      #hist(rgamma(n.offs*10, shape = 0.5, rate = 0.1), breaks = 50) # histogram of distribution
      #mean(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
      #var(rgamma(n.offs*10, shape = 0.5, rate = 0.5))
      g.shape = 0.5 
      g.rate = 0.1
    }  
    # determine repro success using shape/rate parameters determined above
    pair.rs <- rgamma(n.offs*10, shape = g.shape, rate = g.rate)  # sample from distribution
    pair.rs <- round(pair.rs) # round to get whole numbers
    
    # this whole next part is to get us exactly n.offs offspring
    # basic procdure is to get slightly less than n.offs (ocasionally will get exactly n.offs) and 
    # randomly add pairs with 1 offspring until reach n.offs
    pair.rs  <- pair.rs[-which(pair.rs == 0)] # remove all 0s
    pair.rs2 <- cumsum(pair.rs)  # take cumlative sum of pair.rs
    
    #try really hard to get something that does not sum to zero
    loops = 0
    while(sum(pair.rs2)==0){
      loops = loops + 1
      pair.rs <- rgamma(n.offs*10, shape = g.shape, rate = g.rate)  # sample from distribution
      pair.rs <- round(pair.rs) # round to get whole numbers
      pair.rs  <- pair.rs[-which(pair.rs == 0)] # remove all 0s
      pair.rs2 <- cumsum(pair.rs)  # take cumlative sum of pair.rs
      if(loops>999){
        break
      }
    }
    
    #if unlucky with all 0, try again
    if(sum(pair.rs2)==0){
      while(sum(pair.rs2)==0){
        loops = loops + 1
        pair.rs <- rgamma(n.offs*10, shape = g.shape, rate = g.rate)  # sample from distribution
        pair.rs <- round(pair.rs) # round to get whole numbers
        pair.rs  <- pair.rs[-which(pair.rs == 0)] # remove all 0s
        pair.rs2 <- cumsum(pair.rs)  # take cumlative sum of pair.rs
        if(loops>999){
          break
        }
      }
    }
    
    #if first value is larger than the number of offspring needed in total, have one pair produce all offspring
    if(pair.rs2[1]>n.offs){
      pairs = n.offs
      return(pairs)
    }else {
      closest  <- which(abs(pair.rs2-n.offs) == min(abs(pair.rs2-n.offs))) # the first x individuals in pair.rs are cloest to n.offs
      if(length(closest) > 1) {closest <- closest[1]}
      
      n.sampled <- pair.rs2[closest] # are we > or < n.offs
      if(n.sampled > n.offs) {closest <- closest-1} # if > n.offs take one less so that we are always less than n.offs
      
      rs <- pair.rs[1:closest] # take all pairs
      
      add.off <- n.offs-sum(rs)  # how many extra offspring do we need to add
      pairs <- c(rs, rep(1, add.off))
      return(pairs)
    }  
  } 
}
